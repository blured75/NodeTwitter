{"version":3,"file":"static/webpack/static/development/pages/ute.js.4752e08dcef7b412c107.hot-update.js","sources":["webpack:///./utils/JSON2.js"],"sourcesContent":["if (typeof JSON.decycle !== \"function\") {\n    JSON.decycle = function decycle(object, replacer) {\n        \"use strict\";\n\n        // Make a deep copy of an object or array, assuring that there is at most\n        // one instance of each object or array in the resulting structure. The\n        // duplicate references (which might be forming cycles) are replaced with\n        // an object of the form\n\n        //      {\"$ref\": PATH}\n\n        // where the PATH is a JSONPath string that locates the first occurance.\n\n        // So,\n\n        //      var a = [];\n        //      a[0] = a;\n        //      return JSON.stringify(JSON.decycle(a));\n\n        // produces the string '[{\"$ref\":\"$\"}]'.\n\n        // If a replacer function is provided, then it will be called for each value.\n        // A replacer function receives a value and returns a replacement value.\n\n        // JSONPath is used to locate the unique object. $ indicates the top level of\n        // the object or array. [NUMBER] or [STRING] indicates a child element or\n        // property.\n\n        var objects = new WeakMap();     // object to path mappings\n\n        return (function derez(value, path) {\n\n            // The derez function recurses through the object, producing the deep copy.\n\n            var old_path;   // The path of an earlier occurance of value\n            var nu;         // The new object or array\n\n            // If a replacer function was provided, then call it to get a replacement value.\n\n            if (replacer !== undefined) {\n                value = replacer(value);\n            }\n\n            // typeof null === \"object\", so go on if this value is really an object but not\n            // one of the weird builtin objects.\n\n            if (\n                typeof value === \"object\"\n                && value !== null\n                && !(value instanceof Boolean)\n                && !(value instanceof Date)\n                && !(value instanceof Number)\n                && !(value instanceof RegExp)\n                && !(value instanceof String)\n            ) {\n\n                // If the value is an object or array, look to see if we have already\n                // encountered it. If so, return a {\"$ref\":PATH} object. This uses an\n                // ES6 WeakMap.\n\n                old_path = objects.get(value);\n                if (old_path !== undefined) {\n                    return {$ref: old_path};\n                }\n\n                // Otherwise, accumulate the unique value and its path.\n\n                objects.set(value, path);\n\n                // If it is an array, replicate the array.\n\n                if (Array.isArray(value)) {\n                    nu = [];\n                    value.forEach(function (element, i) {\n                        nu[i] = derez(element, path + \"[\" + i + \"]\");\n                    });\n                } else {\n\n                    // If it is an object, replicate the object.\n\n                    nu = {};\n                    Object.keys(value).forEach(function (name) {\n                        nu[name] = derez(\n                            value[name],\n                            path + \"[\" + JSON.stringify(name) + \"]\"\n                        );\n                    });\n                }\n                return nu;\n            }\n            return value;\n        }(object, \"$\"));\n    };\n}\n\n\nif (typeof JSON.retrocycle !== \"function\") {\n    JSON.retrocycle = function retrocycle($) {\n        \"use strict\";\n\n        // Restore an object that was reduced by decycle. Members whose values are\n        // objects of the form\n        //      {$ref: PATH}\n        // are replaced with references to the value found by the PATH. This will\n        // restore cycles. The object will be mutated.\n\n        // The eval function is used to locate the values described by a PATH. The\n        // root object is kept in a $ variable. A regular expression is used to\n        // assure that the PATH is extremely well formed. The regexp contains nested\n        // * quantifiers. That has been known to have extremely bad performance\n        // problems on some browsers for very long strings. A PATH is expected to be\n        // reasonably short. A PATH is allowed to belong to a very restricted subset of\n        // Goessner's JSONPath.\n\n        // So,\n        //      var s = '[{\"$ref\":\"$\"}]';\n        //      return JSON.retrocycle(JSON.parse(s));\n        // produces an array containing a single element which is the array itself.\n\n        var px = /^\\$(?:\\[(?:\\d+|\"(?:[^\\\\\"\\u0000-\\u001f]|\\\\(?:[\\\\\"\\/bfnrt]|u[0-9a-zA-Z]{4}))*\")\\])*$/;\n\n        (function rez(value) {\n\n            // The rez function walks recursively through the object looking for $ref\n            // properties. When it finds one that has a value that is a path, then it\n            // replaces the $ref object with a reference to the value that is found by\n            // the path.\n\n            if (value && typeof value === \"object\") {\n                if (Array.isArray(value)) {\n                    value.forEach(function (element, i) {\n                        if (typeof element === \"object\" && element !== null) {\n                            var path = element.$ref;\n                            if (typeof path === \"string\" && px.test(path)) {\n                                value[i] = eval(path);\n                            } else {\n                                rez(element);\n                            }\n                        }\n                    });\n                } else {\n                    Object.keys(value).forEach(function (name) {\n                        var item = value[name];\n                        if (typeof item === \"object\" && item !== null) {\n                            var path = item.$ref;\n                            if (typeof path === \"string\" && px.test(path)) {\n                                value[name] = eval(path);\n                            } else {\n                                rez(item);\n                            }\n                        }\n                    });\n                }\n            }\n        }($));\n\n        $ = JSON.stringify(JSON.parse(serializedData),null,2)\n\n        return $;\n    };\n}\n\nclass JSON2 {\n    static stringify(jsObject) {\n        if (typeof jsObject == \"undefined\") return \"undefined\"\n        let serializedData = JSON.stringify(JSON.decycle(jsObject))\n\n        return serializedData\n    }\n\n\n    \n}\n\nexports = module.exports =  JSON2"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AAGA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAAA;AAUA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAIA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;AACA;AACA;AACA;AAEA;AACA;;;;;AAMA;;;;A","sourceRoot":""}