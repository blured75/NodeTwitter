{"version":3,"file":"static/webpack/static/development/pages/ute.js.e595480b60e110280af2.hot-update.js","sources":["webpack:///./pages/ute.js"],"sourcesContent":["import React from 'react'\nimport Head from 'next/head'\nimport cowsay from 'cowsay-browser'\nimport Layout from '../components/MyLayout.js'\n\nclass Ute extends React.Component {\n    static async getInitialProps({ req }) {\n        console.log(\"getInitialProps de Ute\")\n        console.log(`${this.cyclicStringify(req)}`)\n        const userAgent = req ? req.headers['user-agent'] : navigator.userAgent;\n        return { userAgent };\n    }\n\n    render() {\n\n        return (\n            <Layout>\n                <div>\n                    <Head>\n                        <title>Et bien voilà ma fois c'est pratique nextJS ça permet de faire des sites moches</title>\n                        <meta name=\"viewport\" content=\"initial-scale=1.0, width=device-width\" />\n                    </Head>\n                    <img src=\"/static/cacajava.svg\"/>\n                    <pre>{cowsay.say({ text: `Ute est russe! et ton navigateur c est ${this.props.userAgent}` })}</pre>\n                </div>\n            </Layout>\n        )\n    }\n\n    static cyclicStringify(jsObject) {\n        // this will successfully serialize objects with cyclic\n        // references by supplying @name for an object already\n        // serialized instead of passing the actual object again,\n        // thus breaking the vicious circle\n        var alreadyVisited = [];\n        var serializedData = JSON.stringify(jsObject, function(key, value) {\n            \n            console.log()\n\n            if (value != null && typeof value == \"object\") {\n                if (alreadyVisited.indexOf(value.name) >= 0) {\n                    // do something other that putting the reference, like\n                    // putting some name that you can use to build the\n                    // reference again later, for eg.\n                    return \"@\" + value.name;\n                }\n                alreadyVisited.push(value.name);\n            }\n            return value;\n        });\n        // return modified, sanitized result\n        serializedData = JSON.stringify(JSON.parse(serializedData),null,2)\n\n        return serializedData\n    }\n\n    static decycle(jsObject) {\n        /*\n            cycle.js\n            2018-05-15\n            Public Domain.\n            NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\n            This code should be minified before deployment.\n            See http://javascript.crockford.com/jsmin.html\n            USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO\n            NOT CONTROL.\n        */\n\n        // The file uses the WeakMap feature of ES6.\n\n        /*jslint eval */\n\n        /*property\n            $ref, decycle, forEach, get, indexOf, isArray, keys, length, push,\n            retrocycle, set, stringify, test\n        */\n\n        if (typeof JSON.decycle !== \"function\") {\n            JSON.decycle = function decycle(object, replacer) {\n                \"use strict\";\n\n        // Make a deep copy of an object or array, assuring that there is at most\n        // one instance of each object or array in the resulting structure. The\n        // duplicate references (which might be forming cycles) are replaced with\n        // an object of the form\n\n        //      {\"$ref\": PATH}\n\n        // where the PATH is a JSONPath string that locates the first occurance.\n\n        // So,\n\n        //      var a = [];\n        //      a[0] = a;\n        //      return JSON.stringify(JSON.decycle(a));\n\n        // produces the string '[{\"$ref\":\"$\"}]'.\n\n        // If a replacer function is provided, then it will be called for each value.\n        // A replacer function receives a value and returns a replacement value.\n\n        // JSONPath is used to locate the unique object. $ indicates the top level of\n        // the object or array. [NUMBER] or [STRING] indicates a child element or\n        // property.\n\n                var objects = new WeakMap();     // object to path mappings\n\n                return (function derez(value, path) {\n\n        // The derez function recurses through the object, producing the deep copy.\n\n                    var old_path;   // The path of an earlier occurance of value\n                    var nu;         // The new object or array\n\n        // If a replacer function was provided, then call it to get a replacement value.\n\n                    if (replacer !== undefined) {\n                        value = replacer(value);\n                    }\n\n        // typeof null === \"object\", so go on if this value is really an object but not\n        // one of the weird builtin objects.\n\n                    if (\n                        typeof value === \"object\"\n                        && value !== null\n                        && !(value instanceof Boolean)\n                        && !(value instanceof Date)\n                        && !(value instanceof Number)\n                        && !(value instanceof RegExp)\n                        && !(value instanceof String)\n                    ) {\n\n        // If the value is an object or array, look to see if we have already\n        // encountered it. If so, return a {\"$ref\":PATH} object. This uses an\n        // ES6 WeakMap.\n\n                        old_path = objects.get(value);\n                        if (old_path !== undefined) {\n                            return {$ref: old_path};\n                        }\n\n        // Otherwise, accumulate the unique value and its path.\n\n                        objects.set(value, path);\n\n        // If it is an array, replicate the array.\n\n                        if (Array.isArray(value)) {\n                            nu = [];\n                            value.forEach(function (element, i) {\n                                nu[i] = derez(element, path + \"[\" + i + \"]\");\n                            });\n                        } else {\n\n        // If it is an object, replicate the object.\n\n                            nu = {};\n                            Object.keys(value).forEach(function (name) {\n                                nu[name] = derez(\n                                    value[name],\n                                    path + \"[\" + JSON.stringify(name) + \"]\"\n                                );\n                            });\n                        }\n                        return nu;\n                    }\n                    return value;\n                }(object, \"$\"));\n            };\n        }\n\n\n        if (typeof JSON.retrocycle !== \"function\") {\n            JSON.retrocycle = function retrocycle($) {\n                \"use strict\";\n\n        // Restore an object that was reduced by decycle. Members whose values are\n        // objects of the form\n        //      {$ref: PATH}\n        // are replaced with references to the value found by the PATH. This will\n        // restore cycles. The object will be mutated.\n\n        // The eval function is used to locate the values described by a PATH. The\n        // root object is kept in a $ variable. A regular expression is used to\n        // assure that the PATH is extremely well formed. The regexp contains nested\n        // * quantifiers. That has been known to have extremely bad performance\n        // problems on some browsers for very long strings. A PATH is expected to be\n        // reasonably short. A PATH is allowed to belong to a very restricted subset of\n        // Goessner's JSONPath.\n\n        // So,\n        //      var s = '[{\"$ref\":\"$\"}]';\n        //      return JSON.retrocycle(JSON.parse(s));\n        // produces an array containing a single element which is the array itself.\n\n                var px = /^\\$(?:\\[(?:\\d+|\"(?:[^\\\\\"\\u0000-\\u001f]|\\\\(?:[\\\\\"\\/bfnrt]|u[0-9a-zA-Z]{4}))*\")\\])*$/;\n\n                (function rez(value) {\n\n        // The rez function walks recursively through the object looking for $ref\n        // properties. When it finds one that has a value that is a path, then it\n        // replaces the $ref object with a reference to the value that is found by\n        // the path.\n\n                    if (value && typeof value === \"object\") {\n                        if (Array.isArray(value)) {\n                            value.forEach(function (element, i) {\n                                if (typeof element === \"object\" && element !== null) {\n                                    var path = element.$ref;\n                                    if (typeof path === \"string\" && px.test(path)) {\n                                        value[i] = eval(path);\n                                    } else {\n                                        rez(element);\n                                    }\n                                }\n                            });\n                        } else {\n                            Object.keys(value).forEach(function (name) {\n                                var item = value[name];\n                                if (typeof item === \"object\" && item !== null) {\n                                    var path = item.$ref;\n                                    if (typeof path === \"string\" && px.test(path)) {\n                                        value[name] = eval(path);\n                                    } else {\n                                        rez(item);\n                                    }\n                                }\n                            });\n                        }\n                    }\n                }($));\n                return $;\n            };\n        }\n    }\n    \n\n}\n\nexport default Ute"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AAQA;AAEA;AAKA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAIA;;;;;;;;;;;;AArBA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;AAkBA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AACA;;;AAEA;AACA;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;;;;AAKA;AACA;AACA;AAGA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAAA;AAUA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AACA;AAIA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;;;AAtOA;AACA;AA0OA;;;;A","sourceRoot":""}