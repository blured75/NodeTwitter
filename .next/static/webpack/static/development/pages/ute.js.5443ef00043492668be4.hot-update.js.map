{"version":3,"file":"static/webpack/static/development/pages/ute.js.5443ef00043492668be4.hot-update.js","sources":["webpack:///./node_modules/@babel/runtime-corejs2/core-js/weak-map.js","webpack:///./node_modules/core-js/library/fn/weak-map.js","webpack:///./node_modules/core-js/library/modules/_collection-weak.js","webpack:///./node_modules/core-js/library/modules/es6.weak-map.js","webpack:///./node_modules/core-js/library/modules/es7.weak-map.from.js","webpack:///./node_modules/core-js/library/modules/es7.weak-map.of.js","webpack:///./pages/ute.js"],"sourcesContent":["module.exports = require(\"core-js/library/fn/weak-map\");","require('../modules/es6.object.to-string');\nrequire('../modules/web.dom.iterable');\nrequire('../modules/es6.weak-map');\nrequire('../modules/es7.weak-map.of');\nrequire('../modules/es7.weak-map.from');\nmodule.exports = require('../modules/_core').WeakMap;\n","'use strict';\nvar redefineAll = require('./_redefine-all');\nvar getWeak = require('./_meta').getWeak;\nvar anObject = require('./_an-object');\nvar isObject = require('./_is-object');\nvar anInstance = require('./_an-instance');\nvar forOf = require('./_for-of');\nvar createArrayMethod = require('./_array-methods');\nvar $has = require('./_has');\nvar validate = require('./_validate-collection');\nvar arrayFind = createArrayMethod(5);\nvar arrayFindIndex = createArrayMethod(6);\nvar id = 0;\n\n// fallback for uncaught frozen keys\nvar uncaughtFrozenStore = function (that) {\n  return that._l || (that._l = new UncaughtFrozenStore());\n};\nvar UncaughtFrozenStore = function () {\n  this.a = [];\n};\nvar findUncaughtFrozen = function (store, key) {\n  return arrayFind(store.a, function (it) {\n    return it[0] === key;\n  });\n};\nUncaughtFrozenStore.prototype = {\n  get: function (key) {\n    var entry = findUncaughtFrozen(this, key);\n    if (entry) return entry[1];\n  },\n  has: function (key) {\n    return !!findUncaughtFrozen(this, key);\n  },\n  set: function (key, value) {\n    var entry = findUncaughtFrozen(this, key);\n    if (entry) entry[1] = value;\n    else this.a.push([key, value]);\n  },\n  'delete': function (key) {\n    var index = arrayFindIndex(this.a, function (it) {\n      return it[0] === key;\n    });\n    if (~index) this.a.splice(index, 1);\n    return !!~index;\n  }\n};\n\nmodule.exports = {\n  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {\n    var C = wrapper(function (that, iterable) {\n      anInstance(that, C, NAME, '_i');\n      that._t = NAME;      // collection type\n      that._i = id++;      // collection id\n      that._l = undefined; // leak store for uncaught frozen objects\n      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);\n    });\n    redefineAll(C.prototype, {\n      // 23.3.3.2 WeakMap.prototype.delete(key)\n      // 23.4.3.3 WeakSet.prototype.delete(value)\n      'delete': function (key) {\n        if (!isObject(key)) return false;\n        var data = getWeak(key);\n        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);\n        return data && $has(data, this._i) && delete data[this._i];\n      },\n      // 23.3.3.4 WeakMap.prototype.has(key)\n      // 23.4.3.4 WeakSet.prototype.has(value)\n      has: function has(key) {\n        if (!isObject(key)) return false;\n        var data = getWeak(key);\n        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);\n        return data && $has(data, this._i);\n      }\n    });\n    return C;\n  },\n  def: function (that, key, value) {\n    var data = getWeak(anObject(key), true);\n    if (data === true) uncaughtFrozenStore(that).set(key, value);\n    else data[that._i] = value;\n    return that;\n  },\n  ufstore: uncaughtFrozenStore\n};\n","'use strict';\nvar global = require('./_global');\nvar each = require('./_array-methods')(0);\nvar redefine = require('./_redefine');\nvar meta = require('./_meta');\nvar assign = require('./_object-assign');\nvar weak = require('./_collection-weak');\nvar isObject = require('./_is-object');\nvar validate = require('./_validate-collection');\nvar NATIVE_WEAK_MAP = require('./_validate-collection');\nvar IS_IE11 = !global.ActiveXObject && 'ActiveXObject' in global;\nvar WEAK_MAP = 'WeakMap';\nvar getWeak = meta.getWeak;\nvar isExtensible = Object.isExtensible;\nvar uncaughtFrozenStore = weak.ufstore;\nvar InternalMap;\n\nvar wrapper = function (get) {\n  return function WeakMap() {\n    return get(this, arguments.length > 0 ? arguments[0] : undefined);\n  };\n};\n\nvar methods = {\n  // 23.3.3.3 WeakMap.prototype.get(key)\n  get: function get(key) {\n    if (isObject(key)) {\n      var data = getWeak(key);\n      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);\n      return data ? data[this._i] : undefined;\n    }\n  },\n  // 23.3.3.5 WeakMap.prototype.set(key, value)\n  set: function set(key, value) {\n    return weak.def(validate(this, WEAK_MAP), key, value);\n  }\n};\n\n// 23.3 WeakMap Objects\nvar $WeakMap = module.exports = require('./_collection')(WEAK_MAP, wrapper, methods, weak, true, true);\n\n// IE11 WeakMap frozen keys fix\nif (NATIVE_WEAK_MAP && IS_IE11) {\n  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);\n  assign(InternalMap.prototype, methods);\n  meta.NEED = true;\n  each(['delete', 'has', 'get', 'set'], function (key) {\n    var proto = $WeakMap.prototype;\n    var method = proto[key];\n    redefine(proto, key, function (a, b) {\n      // store frozen objects on internal weakmap shim\n      if (isObject(a) && !isExtensible(a)) {\n        if (!this._f) this._f = new InternalMap();\n        var result = this._f[key](a, b);\n        return key == 'set' ? this : result;\n      // store all the rest on native weakmap\n      } return method.call(this, a, b);\n    });\n  });\n}\n","// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from\nrequire('./_set-collection-from')('WeakMap');\n","// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of\nrequire('./_set-collection-of')('WeakMap');\n","import React from 'react'\nimport Head from 'next/head'\nimport cowsay from 'cowsay-browser'\nimport Layout from '../components/MyLayout.js'\n\nclass Ute extends React.Component {\n    static async getInitialProps({ req }) {\n        console.log(\"getInitialProps de Ute\")\n        console.log(`${this.cyclicStringify(req)}`)\n        const userAgent = req ? req.headers['user-agent'] : navigator.userAgent;\n        return { userAgent };\n    }\n\n    render() {\n\n        return (\n            <Layout>\n                <div>\n                    <Head>\n                        <title>Et bien voilà ma fois c'est pratique nextJS ça permet de faire des sites moches</title>\n                        <meta name=\"viewport\" content=\"initial-scale=1.0, width=device-width\" />\n                    </Head>\n                    <img src=\"/static/cacajava.svg\"/>\n                    <pre>{cowsay.say({ text: `Ute est russe! et ton navigateur c est ${this.props.userAgent}` })}</pre>\n                </div>\n            </Layout>\n        )\n    }\n\n    static cyclicStringify(jsObject) {\n        // this will successfully serialize objects with cyclic\n        // references by supplying @name for an object already\n        // serialized instead of passing the actual object again,\n        // thus breaking the vicious circle\n        var alreadyVisited = [];\n        var serializedData = JSON.stringify(jsObject, function(key, value) {\n            \n            console.log()\n\n            if (value != null && typeof value == \"object\") {\n                if (alreadyVisited.indexOf(value.name) >= 0) {\n                    // do something other that putting the reference, like\n                    // putting some name that you can use to build the\n                    // reference again later, for eg.\n                    return \"@\" + value.name;\n                }\n                alreadyVisited.push(value.name);\n            }\n            return value;\n        });\n        // return modified, sanitized result\n        serializedData = JSON.stringify(JSON.parse(serializedData),null,2)\n\n        return serializedData\n    }\n\n    static decycle(object) {\n        /*\n            cycle.js\n            2018-05-15\n            Public Domain.\n            NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\n            This code should be minified before deployment.\n            See http://javascript.crockford.com/jsmin.html\n            USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO\n            NOT CONTROL.\n        */\n\n        // The file uses the WeakMap feature of ES6.\n\n        /*jslint eval */\n\n        /*property\n            $ref, decycle, forEach, get, indexOf, isArray, keys, length, push,\n            retrocycle, set, stringify, test\n        */\n\n        if (typeof JSON.decycle !== \"function\") {\n            JSON.decycle = function decycle(object, replacer) {\n                \"use strict\";\n\n        // Make a deep copy of an object or array, assuring that there is at most\n        // one instance of each object or array in the resulting structure. The\n        // duplicate references (which might be forming cycles) are replaced with\n        // an object of the form\n\n        //      {\"$ref\": PATH}\n\n        // where the PATH is a JSONPath string that locates the first occurance.\n\n        // So,\n\n        //      var a = [];\n        //      a[0] = a;\n        //      return JSON.stringify(JSON.decycle(a));\n\n        // produces the string '[{\"$ref\":\"$\"}]'.\n\n        // If a replacer function is provided, then it will be called for each value.\n        // A replacer function receives a value and returns a replacement value.\n\n        // JSONPath is used to locate the unique object. $ indicates the top level of\n        // the object or array. [NUMBER] or [STRING] indicates a child element or\n        // property.\n\n                var objects = new WeakMap();     // object to path mappings\n\n                return (function derez(value, path) {\n\n        // The derez function recurses through the object, producing the deep copy.\n\n                    var old_path;   // The path of an earlier occurance of value\n                    var nu;         // The new object or array\n\n        // If a replacer function was provided, then call it to get a replacement value.\n\n                    if (replacer !== undefined) {\n                        value = replacer(value);\n                    }\n\n        // typeof null === \"object\", so go on if this value is really an object but not\n        // one of the weird builtin objects.\n\n                    if (\n                        typeof value === \"object\"\n                        && value !== null\n                        && !(value instanceof Boolean)\n                        && !(value instanceof Date)\n                        && !(value instanceof Number)\n                        && !(value instanceof RegExp)\n                        && !(value instanceof String)\n                    ) {\n\n        // If the value is an object or array, look to see if we have already\n        // encountered it. If so, return a {\"$ref\":PATH} object. This uses an\n        // ES6 WeakMap.\n\n                        old_path = objects.get(value);\n                        if (old_path !== undefined) {\n                            return {$ref: old_path};\n                        }\n\n        // Otherwise, accumulate the unique value and its path.\n\n                        objects.set(value, path);\n\n        // If it is an array, replicate the array.\n\n                        if (Array.isArray(value)) {\n                            nu = [];\n                            value.forEach(function (element, i) {\n                                nu[i] = derez(element, path + \"[\" + i + \"]\");\n                            });\n                        } else {\n\n        // If it is an object, replicate the object.\n\n                            nu = {};\n                            Object.keys(value).forEach(function (name) {\n                                nu[name] = derez(\n                                    value[name],\n                                    path + \"[\" + JSON.stringify(name) + \"]\"\n                                );\n                            });\n                        }\n                        return nu;\n                    }\n                    return value;\n                }(object, \"$\"));\n            };\n        }\n\n\n        if (typeof JSON.retrocycle !== \"function\") {\n            JSON.retrocycle = function retrocycle($) {\n                \"use strict\";\n\n        // Restore an object that was reduced by decycle. Members whose values are\n        // objects of the form\n        //      {$ref: PATH}\n        // are replaced with references to the value found by the PATH. This will\n        // restore cycles. The object will be mutated.\n\n        // The eval function is used to locate the values described by a PATH. The\n        // root object is kept in a $ variable. A regular expression is used to\n        // assure that the PATH is extremely well formed. The regexp contains nested\n        // * quantifiers. That has been known to have extremely bad performance\n        // problems on some browsers for very long strings. A PATH is expected to be\n        // reasonably short. A PATH is allowed to belong to a very restricted subset of\n        // Goessner's JSONPath.\n\n        // So,\n        //      var s = '[{\"$ref\":\"$\"}]';\n        //      return JSON.retrocycle(JSON.parse(s));\n        // produces an array containing a single element which is the array itself.\n\n                var px = /^\\$(?:\\[(?:\\d+|\"(?:[^\\\\\"\\u0000-\\u001f]|\\\\(?:[\\\\\"\\/bfnrt]|u[0-9a-zA-Z]{4}))*\")\\])*$/;\n\n                (function rez(value) {\n\n        // The rez function walks recursively through the object looking for $ref\n        // properties. When it finds one that has a value that is a path, then it\n        // replaces the $ref object with a reference to the value that is found by\n        // the path.\n\n                    if (value && typeof value === \"object\") {\n                        if (Array.isArray(value)) {\n                            value.forEach(function (element, i) {\n                                if (typeof element === \"object\" && element !== null) {\n                                    var path = element.$ref;\n                                    if (typeof path === \"string\" && px.test(path)) {\n                                        value[i] = eval(path);\n                                    } else {\n                                        rez(element);\n                                    }\n                                }\n                            });\n                        } else {\n                            Object.keys(value).forEach(function (name) {\n                                var item = value[name];\n                                if (typeof item === \"object\" && item !== null) {\n                                    var path = item.$ref;\n                                    if (typeof path === \"string\" && px.test(path)) {\n                                        value[name] = eval(path);\n                                    } else {\n                                        rez(item);\n                                    }\n                                }\n                            });\n                        }\n                    }\n                }($));\n                return $;\n            };\n        }\n    }\n    \n\n}\n\nexport default Ute"],"mappings":";;;;;;;;;AAAA;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3DA;AACA;;;;;;;;;;;;ACDA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AAQA;AAEA;AAKA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAIA;;;;;;;;;;;;AArBA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;AAkBA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AACA;;;AAEA;AACA;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;;;;AAKA;AACA;AACA;AAGA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAAA;AAUA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AACA;AAIA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;;;AAtOA;AACA;AA0OA;;;;A","sourceRoot":""}